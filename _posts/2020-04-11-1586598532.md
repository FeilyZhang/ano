# Project: Introduction to The Design and Analysis of Algorithms(4)

Here's the table of contents:

1. TOC
{:toc}

## 折半查找

对非降序数组元素的查找，通过减常因子实现，效率很高，代码如下

```javascript
function search(arr, l, r, t) {
    if (l <= r) {
        var mid = parseInt((l + r) / 2);
        if (t == arr[mid]) return mid;
        else if (t < arr[mid]) return search(arr, l, mid - 1, t);
        else return search(arr, mid + 1, r, t);
    }
    return -1;
}
```

## 假币问题

在$n$枚外观相同的硬币中，有一枚是假币，已知假币最轻，真币较重，请设计算法求出该假币。

该问题适合减治法求解，减常因子，由于天平一次性可比较任意两组硬币，因此通过减半可以很快发现这枚假币，具体思路如下

+ 若硬币个数为偶数，那么先将硬币分为数目相同的两组，分别计算每组的总重量，第一组大于第二组，那么说明假币在第二组中，递归处理第二组，否则递归处理第一组；
+ 若硬币个数为奇数，那么先将硬币的最后一枚单独提取出来，然后将剩余偶数的硬币分为数目相同的两组，分别计算每组的总重量，若两组相同，那么单独提取出的那一枚一定是假币，否则按情况递归处理某一半；
+ 递归出口一定会存在两种情况，第一种是最终只剩下两枚硬币，那么假币肯定是两枚中的一枚；第二种情况是剩下三枚硬币，那么假币肯定存在于这三者之中。

定义如下函数实现识别假币

+ `odd(l, r)`: 判断某个范围是否为奇数个;
+ `sum(arr, l, r, rst)`: 求某个范围的序列之和;
+ `fakeCoin(arr, l, r)`: 识别假币。

```javascript
function odd(l, r) {
    return (r - l + 1) % 2 != 0;
}

function sum(arr, l, r, rst) {
    while (l <= r) {
        rst += arr[r--];
    }
    return rst;
}

function fakeCoin(arr, l, r) {
    var isOdd = odd(l, r);
    if (!isOdd) {
        var mid = parseInt((l + r) / 2);
        // Compare the last two numbers and get the result.
        if (l == mid) {
            return arr[l] < arr[r] ? l : r;
        // Counterfeit money on the left.
        } else if (sum(arr, l, mid, 0) < sum(arr, mid + 1, r, 0)) {
            return fakeCoin(arr, l, mid);
        // Counterfeit money on the right.
        } else {
            return fakeCoin(arr, mid + 1, r);
        }
    } else {
        var tail = arr[r];
        var mid = parseInt((l + r) / 2);
        // Compare the last three numbers and get the result.
        if ((r - l + 1) == 3) {
            return arr[l] < arr[l + 1] ? l : (arr[l + 1] < arr[r] ? l + 1 : r);
        // Counterfeit money at the end.
        } else if (sum(arr, l, mid, 0) == sum(arr, mid + 1, r, 0)) {
            return tail;
        // Counterfeit money on the left.
        } else if (sum(arr, l, mid, 0) < sum(arr, mid + 1, r, 0)) {
            return fakeCoin(arr, l, mid);
        // Counterfeit money on the right.
        } else {
            return fakeCoin(arr, mid + 1, r);
        }
    }
}
```

## 以2为底的对数

通过减常因子可以计算以2为底的对数，利用对数运算法则，即

\begin{equation}log_2n = log_2\frac{n}{2} + log_22 = log_2\frac{n}{2} + 1\end{equation}

当$n < 2$时停止递归，所以递归代码如下

```javascript
function log2(n) {
    if (n < 2) return Math.log2(n);
    return log2(n / 2) + 1;
}

log2(5)	// 2.3219280948873626
```

对以2为底的对数结果向下取整，代码为

```javascript
function log2Floor(n, rst) {
    if (n < 2) return Math.floor(Math.log2(n)) + rst;
    return log2Floor(n / 2, rst + 1);
}

log2Floor(5, 0)	// 2
```

## 约瑟夫斯问题

约瑟夫斯问题(Josephus problem)，是以弗拉瓦斯·约瑟夫斯(Flavius Josephus)的名字命名的。约瑟夫斯是一个著名的犹太历史学家，参加并记录了公元33-70年犹太人反抗罗马的起义。约瑟夫斯作为一个将军，设法守住了裘达伯特的堡垒达47天之久，但在城市陷落之后，他和40名顽强的将士在附近的一个洞穴中避难，在那里，这些将士认为投降不如自杀。于是，约瑟夫斯建议每个人应该轮流杀死他旁边的人，而这个顺序是由抽签决定的，而约瑟夫斯有预谋的抓到了最后一签(不是抽签顺序的最后一个，而是杀掉他旁边的人后只剩下他一个人)，并且，作为洞穴中的两个幸存者之一，他说服了他原先的牺牲品一起投降了罗马。

现在问题是，在具有n个人的将士中，按照此规则，哪个人将会是最后的幸存者？对该问题进行建模，首先让n个人围成一个圈，并从1进行编号直至n，然后从编号为1的人开始进行这个残酷的计数，因为是每个人轮流杀死旁边的一个人，因此1号杀死2号然后停止，3号杀死4号然后停止，以此类推，对于$n = 6$的环，杀死的过程如下(某个计数标记为0即杀死该号对应的人)

```
初始状态: 1 2 3 4 5 6
第一次杀: 1 0 3 4 5 6
第二次杀: 1 0 3 0 5 6
第三次杀: 1 0 3 0 5 0
第四次杀: 1 0 0 0 5 0
第五次杀: 0 0 0 0 5 0
```

最终幸存者为5号。因此该问题最终抽象为，对于顺次编号$0 - (n - 1)$的具有n个节点的环，每个节点中0为死亡状态，1为存活状态，然后从0号开始跳跃标记，直至剩下最后一个节点为止，即求解$J(n)$。Java代码如下

```java
public class Josephus {

    public static void main(String[] args) {
        System.out.println(josephus(5));    // 3
        System.out.println(josephus(6));    // 5
        System.out.println(josephus(7));    // 7
        System.out.println(josephus(8));    // 1
        System.out.println(josephus(41));   // 19
    }

    public static int josephus(int n) {
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = 1;
        }
        return mark(arr, n);
    }

    private static int mark(int[] arr, int n) {
        int cur = 0, next = 1, temp = 0;
        while (true) {
            arr[next] = 0;  // Mark it.
            temp = findNext(arr, next + 1, n);
            if (cur != temp) cur = temp;
            else return cur + 1;
            temp = findNext(arr, cur + 1, n);
            if (temp != cur) next = temp;
            else return cur + 1;
        }
    }

    private static int findNext(int[] arr, int base, int n) {
        while (true) {
            if (arr[base % n] == 1) return base % n;
            else base++;
        }
    }
    
}
```

## 猜图片

一个非常流行的解题游戏是这样的：给选手出示42张图片，每行6张，共7行。选手可以给大家做一些是非题，来确定他要寻找的图片，然后进一步要求选手用尽可能少的问题来确定目标图片，给出解决该问题的最有效的算法。

利用减常因子实现该算法的思路为，首先对图片进行顺序编号，从而可以得到一个$7 \times 6$矩阵，矩阵当中，每行非降序排列，且下一行的第一个编号大于上一行的最后一个编号，然后对该矩阵进行搜索，从而确定目标的位置。可以先将二维矩阵映射为一维数组，然后运用折半查找进行搜索，然后再将一维索引映射回去从而得到矩阵的索引。

将二维矩阵映射为一维数组可以利用汇编语言中的段的概念，即二维矩阵的行号可以视为基址，列号可以视为偏移，从而在具有row行col列的二维矩阵中第r行第c列可以等价转化为一维数组的索引$r \times col + c$, $r \times col$表示第r行对应的一维数组始址，$c$表示偏移，从而二者相加便得到一维地址。

将一维索引映射为二维矩阵的索引，不过是二维矩阵索引映射为一维数组索引的反操作，在索引为$ret$的一维数组中，其对应的二维索引为$[ret / col, ret % col\]$。代码如下

```java
import java.util.Arrays;

public class GuessPic {

    public static void main(String[] args) {
        int[][] arrs = new int[7][6];
        for (int i = 0; i < arrs.length; i++) {
            for (int j = 0; j < arrs[i].length; j++) {
                arrs[i][j] = i * arrs[i].length + j + 1;
            }
        }
        System.out.println(Arrays.toString(guess(arrs, arrs.length, arrs[0].length, 29)));  // [4, 4]
    }
    
    public static int[] guess(int[][] arrs, int row, int col, int target) {
        int[] arr = new int[row * col];
        // Mapping a two-dimensional matrix to a one-dimensional array。
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                arr[i * col + j] = arrs[i][j];
            }
        }
        // Mapping one-dimensional index to two-dimensional index。
        int ret = search(arr, 0, arr.length - 1, target);
        return new int[] {ret / col, ret % col};
    }

    public static int search(int[] arr, int l, int r, int target) {
        if (l <= r) {
            int m = (l + r) / 2;
            if (arr[m] == target) return m;
            else if (arr[m] < target) return search(arr, m + 1, r, target);
            else return search(arr, l, m - 1, target);
        }
        return -1;
    }
    
}
```
